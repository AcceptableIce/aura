/*
 * Copyright (C) 2012 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.auraframework.service;

import java.io.IOException;
import java.lang.reflect.*;
import java.util.List;


import com.google.common.collect.Lists;

import org.auraframework.impl.AuraImplTestCase;
import org.auraframework.system.AuraContext.Access;
import org.auraframework.system.AuraContext.Format;
import org.auraframework.system.AuraContext.Mode;
import org.auraframework.throwable.AuraRuntimeException;
import org.auraframework.util.json.Json;
import org.auraframework.util.json.JsonSerializable;

/**
 */
public abstract class BaseServiceTest<T extends AuraService, C extends BaseServiceTest.Config> extends
        AuraImplTestCase {

    protected T service;
    protected C config;
    Class<T> serviceClass;
    protected Method meth;
    protected Method auraMethod;

    public BaseServiceTest(String name) {
        super(name);
        shouldSetupContext = false;
    }

    @Override
    public void runTest() throws Throwable {
        // for the case generated by the dummy testNothing method, really do nothing
        if (auraMethod == null) { return; }

        Object service = auraMethod.invoke(null);
        setService(serviceClass.cast(service));
        Object[] params = getParameterList(meth);

        List<C> configs = getConfigs();

        List<C> failedConfigs = Lists.newArrayList();
        Throwable failure = null;

        for (C config : configs) {
            setConfig(config);
            try {
                meth.invoke(this, params);
            } catch (InvocationTargetException e) {
                if (failure == null) {
                    failure = e.getCause();
                }
                failedConfigs.add(config);
            }
        }

        if (failure != null) {
            StringBuilder msg = (failure.getMessage() != null) ? new StringBuilder(failure.getMessage()) : new StringBuilder();
            if (failedConfigs.size() == configs.size()) {
                if (configs.size() > 1) {
                    msg.append(String.format(
                            "\n\nThe trace shown is for the first failure, but all %s configs failed.\n",
                            configs.size()));
                }
            } else {
                Config firstConfig = failedConfigs.get(0);
                msg.append(String.format("%s \n\n Failed with config : %s", failure.getMessage(),
                        firstConfig.toString()));

                if (failedConfigs.size() > 1) {
                    msg.append(String.format("\n\nA total of %s configs were tested, of which %s failed.",
                            configs.size(), failedConfigs.size()));
                    msg.append("\nThe trace shown is for the first failure, but the following configs also failed:");
                    for (int i = 1; i < failedConfigs.size(); i++) {
                        msg.append('\n');
                        msg.append(failedConfigs.get(i).toString());
                    }
                }
            }

            StackTraceElement[] trace = failure.getStackTrace();
            int length = trace.length;
            loop: for (int i = 0; i < trace.length; i++) {
                StackTraceElement element = trace[i];
                if (element.getClassName().equals("org.auraframework.AuraTest$AuraServiceMethodTestCase")
                        && element.getMethodName().equals("runTest")) {
                    length = i + 1;
                    for (int j = i - 1; j >= 0; j--) {
                        element = trace[j];
                        if (!element.getClassName().startsWith("aura")) {
                            length--;
                        } else {
                            break loop;
                        }
                    }
                }
            }

            StackTraceElement[] cleanedTrace = new StackTraceElement[length];
            for (int i = 0; i < cleanedTrace.length; i++) {
                cleanedTrace[i] = trace[i];
            }

            failure.setStackTrace(cleanedTrace);

            AuraRuntimeException e = new AuraRuntimeException(msg.toString(), failure);
            e.setStackTrace(new StackTraceElement[0]);
            throw e;
        }
    }

    public Object[] getParameterList(Method method) {
        Class<?>[] parameters = method.getParameterTypes();

        if (parameters== null) {
            return new Object[0];
        }

        List<Object> paramsList = Lists.newArrayList();

        for(Class<?> param : parameters){
            // If its a primitive, null isn't sufficient, you get a invalid cast exception.
            // So use a smart default.
            if(param.isPrimitive()) {
                if(param.equals(Short.TYPE)) paramsList.add(0);
                if(param.equals(Integer.TYPE)) paramsList.add(0);
                if(param.equals(Long.TYPE)) paramsList.add(0);
                if(param.equals(Float.TYPE)) paramsList.add(0);
                if(param.equals(Double.TYPE)) paramsList.add(0);
                if(param.equals(Boolean.TYPE)) paramsList.add(Boolean.FALSE);
            } else {
                paramsList.add(null);
            }
        }

        return paramsList.toArray();
    }

    public abstract List<C> getConfigs();

    public void setMethods(Class<T> serviceClass, Method auraMethod, Method serviceMethod) {
        this.serviceClass = serviceClass;
        this.auraMethod = auraMethod;
        this.meth = serviceMethod;
    }

    public void setService(T service) {
        this.service = service;
    }

    public void setConfig(C config) {
        this.config = config;
    }

    protected T getService() {
        return service;
    }

    protected C getConfig() {
        return config;
    }

    @SuppressWarnings("unchecked")
    protected List<C> permuteConfigs(List<C> configs) {
        List<C> ret = Lists.newArrayList();
        for (C orig : configs) {
            for (Mode mode : Mode.values()) {
                for (Format format : Format.values()) {
                    for (Access access : Access.values()) {
                        C config;
                        try {
                            config = (C)orig.clone();
                        } catch (CloneNotSupportedException x) {
                            throw new AuraRuntimeException(x);
                        }
                        config.mode = mode;
                        config.format = format;
                        config.access = access;
                        ret.add(config);
                    }
                }
            }
        }

        return ret;
    }

    /**
     * Subclasses of this class are loaded dynamically by AuraTest, so adding this method so that junit doesn't get
     * upset if there are no test methods on the subclass, because in this case, that's ok.
     */
    public void testNothing() {}

    public static class Config implements Cloneable, JsonSerializable {
        public Mode mode = Mode.UTEST;
        public Format format = Format.HTML;
        public Access access = Access.AUTHENTICATED;

        @Override
        public Object clone() throws CloneNotSupportedException {
            return super.clone();
        }

        @Override
        public String toString() {
            return Json.serialize(this, false, false);
        }

        @Override
        public void serialize(Json json) throws IOException {
            json.writeMapBegin();
            for (Field field : this.getClass().getFields()) {
                try {
                    json.writeMapEntry(field.getName(), field.get(this));
                } catch (Exception x) {
                    json.writeMapEntry(field.getName(), "[[unserializable value]]");
                }
            }
            json.writeMapEnd();
        }
    }
}
