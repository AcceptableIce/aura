/**
 * JSDoc plugin to dump out JSON
 */
var fs = require('jsdoc/fs'),
    path = require('jsdoc/path'),
    dir = env.opts.destination,
    out = path.join(dir, 'xml');

exports.handlers = {
	processingComplete: function(e) {
	    var dir = env.opts.destination;
	    // read from symbolSet.json generated by auraExternalOnly.js
	    var content = fs.readFileSync(path.join(dir, 'symbolSet.json'), 'utf8');
		// parse and create the ditamap and xmls.
	    fs.mkPath(out);
	    parse(content);
	}
};

function parse(obj){
    obj = obj.replace(/\"/g, '\\\"').replace(/'/g, '"').replace(/\n/g, '').replace(/\t/g, ' ');
    var json = JSON.parse(obj);
    var objectMap = {};
    for (var i = 0; i < json.length; i++) {
    	var xml = '';
        if (json[i].kind == "function") {
        	var objectName = json[i].memberof;
        	if (objectName) {
        		objectName = objectName.substring(objectName.lastIndexOf('.') + 1);
        	}
        	var functionName = json[i].name;
        	xml = objectFileWriter(objectName, json[i].description, functionName, json[i].returns, json[i].params);
        	fs.writeFileSync(path.join(out, 'ref_jsapi_' + objectName + '_' + functionName + '.xml'), xml, 'utf8');

        	// putting the element to objectMap for ditamap generation.
        	if (objectMap[objectName]) {
        		objectMap[objectName].push(functionName);
        	} else {
        		objectMap[objectName] = [functionName];
        	}
        } else if (json[i].kind == "class") {
        	var objectName = json[i].longname;
        	if (objectName) {
        		objectName = objectName.substring(objectName.lastIndexOf('.') + 1);
        	}
        	xml = objectFileWriter(objectName, json[i].description, null, null, null);
        	fs.writeFileSync(path.join(out, 'ref_jsapi_' + objectName + '.xml'), xml, 'utf8');

        	// putting the element to objectMap for ditamap generation.
        	if (!objectMap[objectName]) {
        		objectMap[objectName] = [];
        	}
        }
    }
    
    // generate ditamap
    fs.writeFileSync(path.join(out, "ref_jsapi.ditamap"), ditaMapWriter(objectMap), 'utf8');
}

function ditaMapWriter(objectMap) {
	var xml = [];
	xml.push('<?xml version="1.0" encoding="UTF-8"?>\n');
	xml.push('<!DOCTYPE map PUBLIC "-//OASIS//DTD DITA Map//EN" "map.dtd">');
	xml.push('<map title="Reference" xml:lang="en-us">\n');
	xml.push('    <!-- DO NOT UNDER ANY CIRCUMSTANCES EDIT THIS FILE IN OXYGEN. Your changes will be lost. This file is auto generated.-->\n');
	for (var objectName in objectMap) {
		if (objectMap.hasOwnProperty(objectName)) {
			xml.push('    <topicref format="dita" href="ref_jsapi_' + objectName + '.xml" scope="local" type="reference" chunk="to-content">\n');
			var methodsArr = objectMap[objectName];
			for (var i = 0; i < methodsArr.length; i++) {
				xml.push('        <topicref format="dita" href="ref_jsapi_' + objectName + '_' + methodsArr[i] + '.xml" scope="local" type="reference"/>\n');
			}
			xml.push('    </topicref>\n');
	    }
	}
	xml.push('</map>\n');

	return xml.join('');
}

function objectFileWriter(objectName, description, functionName, returns, params) {
	if (description) {
		description = description.replace(/<code>/g, '<codeph otherprops="nolang">').replace(/<\/code>/g, '<\/codeph>');
	}

	var xml = [];
	xml.push('<?xml version="1.0" encoding="UTF-8"?>\n');
	xml.push('<!DOCTYPE reference PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">\n');
	xml.push('<reference id="ref_jsapi_' + (objectName ? objectName.toLowerCase() : '') + (functionName == null ? '' : ('_' + functionName.toLowerCase())) + '" xml:lang="en-us">\n');
	xml.push('    <title><ph id="topic-title"><codeph otherprops="javascript">' + (functionName == null ? objectName : (functionName + '()')) + '</codeph></ph></title>\n');
	xml.push('    <shortdesc><ph id="shortdesc"></ph>' + description + '</shortdesc>\n');
	xml.push('    <prolog>\n');
	xml.push('        <metadata>\n');
	xml.push('            <keywords>\n');

	if (functionName != null) {
		xml.push('                <indexterm>Methods <indexterm><codeph otherprops="javascript">' + functionName + '()</codeph></indexterm>\n');
		xml.push('                </indexterm>\n');
		if (objectName) {
			xml.push('                <indexterm><codeph otherprops="javascript">' + objectName + '</codeph>\n');
		}
		xml.push('                    <indexterm><codeph otherprops="javascript">' + functionName + '()</codeph></indexterm>\n');
		xml.push('                </indexterm>\n');
		xml.push('                <indexterm><codeph otherprops="javascript">' + functionName + '()</codeph></indexterm>\n');
	} else {
		xml.push('                <indexterm>' + objectName + 'object</indexterm>\n');
	}

	xml.push('            </keywords>\n');
	xml.push('            <othermeta content="Developer_Guide_Reference" name="app_area"/>\n');
	xml.push('            <othermeta content="Developer" name="role"/>\n');
	xml.push('            <othermeta content="reference" name="topic_type"/>\n');
	xml.push('        </metadata>\n');
	xml.push('    </prolog>\n');
	xml.push('    <refbody>\n');
	xml.push('        <section>\n');

	if (functionName != null) {

		xml.push('            <title>Signature</title>\n');

		var paramsArr = listSectionPrinter(params, 'Parameters');
		var returnsArr = listSectionPrinter(returns, 'Returns');
	
		xml.push('            <p><codeph otherprops="javascript">' + returnsArr[0] + ' ' + functionName + '(' + paramsArr[0] + ')</codeph></p>\n');
		xml.push('        </section>\n');
	
		if (params) {
			xml.push(paramsArr[1]);
		}
		if (returns) {
			xml.push(returnsArr[1]);
		}
	} else {
		xml.push('            <title>Methods</title>\n');
	}
	xml.push('    </refbody>\n');
	xml.push('</reference>\n');

	return xml.join('');
}

/**
 * Generates string/buff for xml doc
 * @param obj A json list element
 * @param type type of input element. Either 'Parameters' or 'Returns'.
 * @returns An array containing two elements: a string (elem1, elem2...) and a string of xml section node
 */
function listSectionPrinter(list, type) {
	var listStr = '';
	var listXmlStr = '';
	if (list) {
		listXml = [];
		listXml.push('        <section>\n');
		listXml.push('            <title>' + type + '</title>\n');
		if ('Returns' == type) {
			listXml.push('            <p>This method is asynchronous so it returns its response in an object in a callback method. The response object contains the following fields:</p>\n');
		}

		var delim = '';
		for (var i = 0; i < list.length; i++) {
			if (list[i].type) {
				listStr = listStr + delim + list[i].type.names[0];
				delim = ', ';
	
				listXml.push('            <dl>\n');
				listXml.push('                <dlentry>\n');
				if ('Parameters' == type) {
					listXml.push('                    <dt><varname>' + list[i].name + '</varname></dt>\n');
					listXml.push('                    <dd>Type: <codeph otherprops="javascript">' + list[i].type.names[0] + '</codeph></dd>\n');
				} else {
					listXml.push('                    <dt>Type: <codeph otherprops="javascript">' + list[i].type.names[0] + '</codeph></dt>\n');
				}
				listXml.push('                    <dd>' + list[i].description + '</dd>\n');
				listXml.push('                </dlentry>\n');
				listXml.push('            </dl>\n');
			}
		}

		listXml.push('        </section>\n');
		listXmlStr = listXml.join('');
	}

	return [listStr, listXmlStr];
}