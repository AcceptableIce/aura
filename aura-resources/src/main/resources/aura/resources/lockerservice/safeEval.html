<!DOCTYPE html>
<html>
<head></head>
<body>
  <script>
  (function (window, placeholder, parent) {
      'use strict';

      var isStrictModeAvailable = (function () { return !this; })();
      // TODO: improve returnable detection. `function (...` is a trick used today
      //       to return arbitrary code from actions, it should be legacy in the future.
      var returnableEx = /^(\s*)([{(["']|function\s*\()/;
      // TODO: improve first comment removal
      var trimFirstMultilineCommentEx = /^\/\*([\s\S]*?)\*\//;
      var trimFirstLineCommentEx = /^\/\/.*\n?/;
      var hookFn = '$globalEvalIIFE$';
      var USE_STRICT = true;

      // This whilelist represents reflective ECMAScript APIs or reflective DOM APIs
      // which, by definition, do not provide authority or access to globals.
      // TODO: grow this list...
      var whitelist = [
              'undefined', 'NaN', 'Date', 'Number', 'Boolean', 'alert', 'confirm',
              'Intl', 'Error', 'console',
              'clearTimeout', 'clearInterval', 'setTimeout', 'setInterval'
          ];

      // wrapping the source with `with` statements create a new lexical scope,
      // that can prevent access to the globals in the worker by shodowing them
      // with the members of new scopes passed as arguments into the `hookFn` call.
      // additionally, when specified, strict mode will be enforced to avoid leaking
      // global variables into the worker.
      function addLexicalScopesToSource(src, levels, useStrict) {
          // removing first line CSFR protection and other comments to facilitate
          // the detection of returnable code
          src = src.replace(trimFirstMultilineCommentEx, '');
          src = src.replace(trimFirstLineCommentEx, '');
          // only add return statement if source it starts with [, {, or (
          var match = src.match(returnableEx);
          if (match) src = src.replace(match[1], 'return ');
          if (useStrict) src = '"use strict";\n' + src;
          src = 'return (function(){\n' + src + '\n})()';
          for (var i = 0; i < levels; i++) {
              src = 'with(arguments[' + i + ']||{}){' + src + '}';
          }
          return 'function ' + hookFn + '(){' + src + '}';
      }

      function evalAndReturn(src) {
          var script = document.createElement('script');
          script.type = 'text/javascript';
          window[hookFn] = undefined;
          script.appendChild(document.createTextNode(src));
          placeholder.appendChild(script);
          placeholder.removeChild(script);
          var result = window[hookFn];
          window[hookFn] = undefined;
          return result;
      }

      // adding non-configurable hooks into parent window.
      Object.defineProperties(parent, {
          '$$safe-eval$$': {
              value: function(src) {
                  if (!isStrictModeAvailable) {
                    throw new Error("$$safe-eval$$ is only supported in strict mode capable browsers!");
                  }
                  if (!src) return undefined;
                  var fn = evalAndReturn(addLexicalScopesToSource(src, arguments.length - 1, USE_STRICT));
                  return fn.apply(undefined, Array.prototype.slice.call(arguments, 1));
              }
          },
          '$$safe-eval-compat$$': {
              value: function(src, globalScope) {
                  if (!src) return undefined;
                  var fn = evalAndReturn(addLexicalScopesToSource(src, arguments.length - 1));
                  return fn.apply(globalScope, Array.prototype.slice.call(arguments, 1));
              }
          }
      });

      // In case the break out of the lock, they might encounter a broken env with
      // no access to `window.parent`.
      try {
          window.parent = undefined;
      } catch (ignoring_bleaching_errors) {}

      // TODO: Extra guarding:
      // - protect against unexpected navigation events
      // - protect against reloads

  })(window, document.body, window.parent);
  </script>
</body>
</html>
