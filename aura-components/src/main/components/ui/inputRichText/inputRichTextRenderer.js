/*
 * Copyright (C) 2013 salesforce.com, inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

({

	afterRender: function (cmp, helper) {
		helper.initEditor(cmp);
		helper.setContent(cmp, cmp.get("v.value"));
		var safeEval = window["$$safe-eval-compat$$"];
		// when locker service is enable, we are facing a big hurtle with ckeditor, it uses a lot of inline scripts
		// for all events, and that doesn't work with our CSP rules. As a result, we need to do a HUGE hack to
		// get the old editor version that we use to work, including patching the editor, and monitoring the
		// dom structure generated by the editor in such a way that we can replace the inline event listeners
		// with real listeners that can perform the right call when triggered.
		if (safeEval && typeof MutationObserver !== "undefined") {
			var target = cmp.find("container").getElement();
			// create an observer instance
			cmp._observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(mutation) {
					Array.prototype.slice.call(mutation.addedNodes).forEach(function (node) {
						if (node && node.querySelectorAll) {
							// dealing with href attempting to evaluate JS
							Array.prototype.slice.call(node.querySelectorAll("[href]")).forEach(function (el) {
								var href = el.getAttribute('href');
								/*eslint-disable no-script-url*/
								if (href && href.indexOf('javascript:') === 0) {
									el.onclick = function (event) {
										event.preventDefault();
									};
								}
							});
							// dealing with all dom events needed for the ckeditor to function
							[
								"onclick", "onfocus", "onblur", "onkeydown", "onkeypress", "onkeyup",
								"onmousedown", "onmouseout", "onmouseover", "onmouseup", "onchange"
							].forEach(function (type) {
								Array.prototype.slice.call(node.querySelectorAll("[" + type + "]")).forEach(function (el) {
									var code = el.getAttribute(type);
									if (code && code !== "") {
										el.removeAttribute(type);
										el.setAttribute('data-' + type, code);
										el[type] = function (event) {
											return safeEval("(function(){" + code + "}).apply($implicitEventElement)", window, {
												event: event,
												$implicitEventElement: el
											});
										};
									}
								});
							});
						}
					});
				});
			});
			// intentionally use of expandos here since the observer is just an internal hack.
			cmp._observer.observe(target, {
				attributes: true,
				subtree: true,
				childList: true
			});
		}
		this.superAfterRender();
	},

	rerender: function (cmp, helper) {
		if (cmp.getConcreteComponent()._updatingValue) {
			//don't rerender when updating value
			return;
		}
		var shouldRender = false;
		var attributes = cmp.getDef().getAttributeDefs();
		attributes.each(function (attributeDef) {
			var name = attributeDef.getDescriptor().getName();
			if (name !== "value" && cmp.isDirty("v." + name)) {
				shouldRender = true;
			} else if (name === "value" && cmp.isDirty("v.value")) {
				//Cannot listen to v.value change event to update content
				//since the parent component inputTextArea also listens v.value change event and update v.value again
				helper.setContent(cmp, cmp.get("v.value"));
			}
		});
		if (shouldRender) {
			this.superRerender();
		}
	},

	unrender: function (cmp, helper) {
		if (cmp._observer) {
			// stop the observing to prevent leaks
			cmp._observer.disconnect();
		}
		helper.unrender(cmp);
		this.superUnrender();
	}
});
